package day05

import locations.Directory.currentDir
import inputs.Input.loadFileSync
import scala.compiletime.ops.int
import scala.compiletime.ops.long

@main def part1: Unit =
  println(s"The solution is ${part1(loadInput())}")

@main def part2: Unit =
  println(s"The solution is ${part2(loadInput())}")

def loadInput(): String = loadFileSync(
  s"$currentDir/../../../../input/day05"
  + "sample"
)

enum Kind:
  case Seed, Soil, Fertilizer, Water, Light, Temparature, Humidity, Location

enum Pair:
  case Mapped(s: Long, len: Long)
  case Unmapped(s: Long, len: Long)

  val start = this match {
    case Mapped(start, len)   => start
    case Unmapped(start, len) => start
  }

  val value =
    this match {
      case Mapped(start, len)   => (start, len)
      case Unmapped(start, len) => (start, len)
    }

  val end =
    this match {
      case Mapped(start, len)   => (start, start + len - 1)
      case Unmapped(start, len) => (start, start + len - 1)
    }

case class MapInfo(src: Long, val srcEnd: Long, dest: Long, val destEnd: Long):

  def findDestination(value: Long) =
    if value <= srcEnd && value >= src
    then Some(dest + (value - src))
    else None

  def findDestination(pair: Pair): Option[(List[Pair], List[Pair])] =

    val (vs, vend) = pair.value

    if vend < src || vs > srcEnd
    then None
    else

      (vs < src, vend > srcEnd) match {
        case (true, true) =>
          Some(
            (
              List(
                Pair.Mapped(dest, destEnd)
              ),
              List(
                Pair.Unmapped(vs, src-1),
                Pair.Unmapped(srcEnd+1, vend)
              )
            )
          )
        case (true, false) =>
          Some(
            (
              List(Pair.Mapped(dest, dest + vend - src + 1)),
              List(Pair.Unmapped(vs, src-1))
            )
          )

        case (false, true) =>
          Some(
            (
              List(Pair.Mapped(dest + (vs - src), destEnd)),
              List(Pair.Unmapped(srcEnd+1, vend))
            )
          )

        case (false, false) =>
          Some(
            (
              List(Pair.Mapped(dest + (vs - src), dest - src + vend + 1)),
              List[Pair]()
            )
          )
      }

case class Almanac(
    seeds: Array[Long],
    mappers: Map[(Kind, Kind), List[MapInfo]]
):
  def findLocationBySeed(sk: Kind, s: Long): Long =
    nextKind(sk) match {
      case Some(dk) =>
        val entries = mappers((sk, dk))
        val x = entries
          .map(mi => mi.findDestination(s))
          .dropWhile(_.isEmpty)
          .toList match {
          case Some(d) :: _ => findLocationBySeed(dk, d)
          case _            => findLocationBySeed(dk, s)
        }
        x
      case None => s
    }

  def loop(pairs: List[Pair], entries: List[MapInfo]) =
    val (ml, uml) = entries
      .foldLeft((List[Pair](), pairs)) { case ((mapped, unmapped), entry) =>
        unmapped.foldLeft((mapped), unmapped) { case ((mapped1, unmapped1), pair) =>
          entry.findDestination(pair) match {
            case Some((mapped2, unmapped2)) =>
              (mapped1 ++ mapped2, unmapped1 ++ unmapped2)
            case None => (mapped1, List())
          }
        }
      }

    ml ++ uml

    // val ls = pairs.map(pair => mi.findDestination(pair))
    // List()

  def findLocationBySeedRange(sk: Kind, pairs: List[Pair]): Long =
    nextKind(sk) match {
      case Some(dk) =>
        val entries = mappers((sk, dk))

        val ls = loop(pairs, entries)

        if ls.isEmpty then findLocationBySeedRange(dk, List(pairs.head))
        else findLocationBySeedRange(dk, ls)

      case None =>
        pairs.map(p => p.value._1).min
    }

def createAlmanac(input: String) =
  input.split("\n\n") match
    case Array(
          seeds_raw,
          seed2soil,
          soil2fertilizer,
          fertilizer2water,
          water2light,
          light2temp,
          tem2hum,
          hum2loc
        ) =>
      def getEntries(s: String) = {
        s.split("\n")
          .drop(1)
          .map { case s"$dest $src $len" =>
            MapInfo(
              src.toLong,
              src.toLong + len.toLong - 1,
              dest.toLong,
              dest.toLong + len.toLong - 1
            )
          }
          .toList
      }

      var mappers: Map[(Kind, Kind), List[MapInfo]] = Map()
      val seeds = seeds_raw match {
        case s"seeds: $rest" =>
          rest.split(" ").map(_.toLong)
      }

      mappers += ((Kind.Seed, Kind.Soil) -> getEntries(seed2soil))
      mappers += ((Kind.Soil, Kind.Fertilizer) -> getEntries(soil2fertilizer))
      mappers += ((Kind.Fertilizer, Kind.Water) -> getEntries(fertilizer2water))
      mappers += ((Kind.Water, Kind.Light) -> getEntries(water2light))
      mappers += ((Kind.Light, Kind.Temparature) -> getEntries(light2temp))
      mappers += ((Kind.Temparature, Kind.Humidity) -> getEntries(tem2hum))
      mappers += ((Kind.Humidity, Kind.Location) -> getEntries(hum2loc))

      Almanac(seeds, mappers)

def nextKind(k: Kind) =
  k match
    case Kind.Seed        => Some(Kind.Soil)
    case Kind.Soil        => Some(Kind.Fertilizer)
    case Kind.Fertilizer  => Some(Kind.Water)
    case Kind.Water       => Some(Kind.Light)
    case Kind.Light       => Some(Kind.Temparature)
    case Kind.Temparature => Some(Kind.Humidity)
    case Kind.Humidity    => Some(Kind.Location)
    case Kind.Location    => None

def part1(input: String): String =
  val almanac = createAlmanac(input)
  almanac.seeds
    .map(s => almanac.findLocationBySeed(Kind.Seed, s))
    .min
    .toString()

def part2(input: String): String =

  val almanac = createAlmanac(input)
  val pairs =
    almanac.seeds
      .grouped(2)
      .map(a => Pair.Unmapped(a(0), a(0) + a(1) - 1))
      .toList
  // val pairs = List(Pair.Unmapped(82, 1))
  // val v = almanac.findLocationBySeed(Kind.Seed, 82)
  val x = almanac.findLocationBySeedRange(Kind.Seed, pairs)
  // println(x)
  x.toString()

@main def part12: Unit =

  val input = loadInput()
