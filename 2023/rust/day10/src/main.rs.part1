use std::{fs, str::FromStr};

#[derive(Clone)]
pub struct Input {
    grid: Vec<Vec<Pipe>>,
    start_pos: (usize, usize),
}

#[derive(PartialEq, Eq, Hash, Clone)]
pub enum Direction {
    East,
    West,
    North,
    South,
}

#[derive(PartialEq, Clone)]
pub enum Pipe {
    V,  // |
    H,  // -
    L,  // L
    J,  // J
    D7, // 7
    F,  // F
    G,  // .
    S,  //S
}

fn get_pipe(c: char) -> Pipe {
    match c {
        '|' => Pipe::V,
        '-' => Pipe::H,
        'L' => Pipe::L,
        'J' => Pipe::J,
        '7' => Pipe::D7,
        'F' => Pipe::F,
        'S' => Pipe::S,
        '.' => Pipe::G,
        _ => Pipe::G,
    }
}

impl Input {
    fn new(s: &str) -> Self {
        let mut start_pos = (0, 0);
        let mut grid: Vec<Vec<Pipe>> = vec![];

        for (r, l) in s.split("\n").enumerate() {
            let mut cells: Vec<Pipe> = vec![];
            for (c, ch) in l.chars().enumerate() {
                if ch == 'S' {
                    start_pos = (r, c);
                }
                cells.push(get_pipe(ch))
            }
            grid.push(cells);
        }

        let (r, c) = start_pos;

        grid[r][c] = Pipe::V;

        Self {
            grid,
            start_pos,
        }
    }

    fn traverse_path(&self, (from, (r, c)): (Direction, (usize, usize)), count: usize) -> usize {
        if count > 0 && self.start_pos == (r, c) {
            count + 1
        } else {
            let (dir, coord) = self.get_connecting_coordinate((r, c), from);
            self.traverse_path((dir, coord), count + 1)
        }
    }

    fn get_connecting_coordinate(
        &self,
        (r, c): (usize, usize),
        onward_dir: Direction,
    ) -> (Direction, (usize, usize)) {
        let target_dir = match self.grid[r][c] {
            Pipe::V => onward_dir,
            Pipe::H => onward_dir,
            Pipe::L => match onward_dir {
                Direction::East => todo!(),
                Direction::West => Direction::North,
                Direction::North =>todo!(),
                Direction::South => Direction::East,
            },
            Pipe::J => match onward_dir {
                Direction::East => Direction::North,
                Direction::West => todo!(),
                Direction::South => Direction::West,
                Direction::North => todo!(),
            },
            Pipe::D7 => match onward_dir {
                Direction::East => Direction::South,
                Direction::West => todo!(),
                Direction::North => Direction::West,
                Direction::South => Direction::South,
            },
            Pipe::F => match onward_dir {
                Direction::East => todo!(),
                Direction::West => Direction::South,
                Direction::North => Direction::East,
                Direction::South => todo!(),
            },
            Pipe::G => todo!(),
            Pipe::S => todo!(),
        };

        if target_dir == Direction::East {
            // if c < self.width - 1 && self.is_connected(Direction::East, (r, c), (r, c + 1)) {
            (Direction::East, (r, c + 1))
            // }
        } else if target_dir == Direction::West {
            // if c > 0 && self.is_connected(Direction::West, (r, c), (r, c - 1)) {
            (Direction::West, (r, c - 1))
            // }
        } else if target_dir == Direction::North {
            // if r > 0 && self.is_connected(Direction::North, (r, c), (r - 1, c)) {
            (Direction::North, (r - 1, c))
            // }
        } else {
            //if target_dir == Direction::South
            // if r < self.height - 1 && self.is_connected(Direction::South, (r, c), (r + 1, c)) {
            (Direction::South, (r + 1, c))
            // }
        }

        // if target_dir == Direction::East {
        //     if c < self.width - 1 && self.is_connected(Direction::East, (r, c), (r, c + 1)) {
        //         ((Direction::East, (r, c + 1)))
        //     }
        // }
        // else if target_dir == Direction::West {
        //     if c > 0 && self.is_connected(Direction::West, (r, c), (r, c - 1)) {
        //         ((Direction::West, (r, c - 1)))
        //     }
        // }
        // else if target_dir == Direction::North {
        //     if r > 0 && self.is_connected(Direction::North, (r, c), (r - 1, c)) {
        //         ((Direction::North, (r - 1, c)))
        //     }
        // }
        // else if target_dir == Direction::South {
        //     if r < self.height - 1 && self.is_connected(Direction::South, (r, c), (r + 1, c)) {
        //         ((Direction::South, (r + 1, c)))
        //     }
        // }
    }

    fn part1(&self) -> String {

        let from = Direction::North;
        let target_pos = self.get_connecting_coordinate(self.start_pos,  from);

        let visited = 0;
        let farthest_length = self.traverse_path(target_pos, visited);

        ((farthest_length+1)/2).to_string()
    }
}

impl FromStr for Input {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Input::new(s))
    }
}

fn main() {
    let contents = fs::read_to_string("../../input/day10").unwrap();
    let input = contents.parse::<Input>().unwrap();
    println!("{}", input.part1());
}
