use std::{collections::HashSet, fs, str::FromStr};

#[derive(Clone)]
pub struct Input {
    grid: Vec<Vec<Pipe>>,
    start_pos: (usize, usize),
}

#[derive(PartialEq, Eq, Hash, Clone)]
pub enum Direction {
    East,
    West,
    North,
    South,
}

#[derive(PartialEq, Clone)]
pub enum Pipe {
    V,  // |
    H,  // -
    L,  // L
    J,  // J
    D7, // 7
    F,  // F
    G,  // .
    S,  //S
}

fn get_pipe(c: char) -> Pipe {
    match c {
        '|' => Pipe::V,
        '-' => Pipe::H,
        'L' => Pipe::L,
        'J' => Pipe::J,
        '7' => Pipe::D7,
        'F' => Pipe::F,
        'S' => Pipe::S,
        '.' => Pipe::G,
        _ => Pipe::G,
    }
}

impl Input {
    fn new(s: &str) -> Self {
        let mut start_pos = (0, 0);
        let mut grid: Vec<Vec<Pipe>> = vec![];

        for (r, l) in s.split("\n").enumerate() {
            let mut cells: Vec<Pipe> = vec![];
            for (c, ch) in l.chars().enumerate() {
                if ch == 'S' {
                    start_pos = (r, c);
                }
                cells.push(get_pipe(ch))
            }
            grid.push(cells);
        }

        let (r, c) = start_pos;

        grid[r][c] = Pipe::V;

        Self { grid, start_pos }
    }

    fn traverse_path(
        &self,
        (from, (r, c)): (Direction, (usize, usize)),
        tiles: &mut HashSet<(usize, usize)>,
    ) -> HashSet<(usize, usize)> {
        if tiles.len() > 0 && self.start_pos == (r, c) {
            tiles.insert(self.start_pos);
            tiles.clone()
        } else {
            let (dir, coord) = self.find_target_direction_and_coordinate((r, c), from);
            tiles.insert(coord);
            self.traverse_path((dir, coord), tiles)
        }
    }

    fn find_target_direction_and_coordinate(
        &self,
        (r, c): (usize, usize),
        onward_dir: Direction,
    ) -> (Direction, (usize, usize)) {
        let target_dir = match self.grid[r][c] {
            Pipe::V => onward_dir,
            Pipe::H => onward_dir,
            Pipe::L => match onward_dir {
                Direction::East => todo!(),
                Direction::West => Direction::North,
                Direction::North => todo!(),
                Direction::South => Direction::East,
            },
            Pipe::J => match onward_dir {
                Direction::East => Direction::North,
                Direction::West => todo!(),
                Direction::South => Direction::West,
                Direction::North => todo!(),
            },
            Pipe::D7 => match onward_dir {
                Direction::East => Direction::South,
                Direction::West => todo!(),
                Direction::North => Direction::West,
                Direction::South => Direction::South,
            },
            Pipe::F => match onward_dir {
                Direction::East => todo!(),
                Direction::West => Direction::South,
                Direction::North => Direction::East,
                Direction::South => todo!(),
            },
            Pipe::G => todo!(),
            Pipe::S => todo!(),
        };

        if target_dir == Direction::East {
            (Direction::East, (r, c + 1))
        } else if target_dir == Direction::West {
            (Direction::West, (r, c - 1))
        } else if target_dir == Direction::North {
            (Direction::North, (r - 1, c))
        } else {
            (Direction::South, (r + 1, c))
        }
    }

    fn mark_sea(
        &mut self,
        (r, c): (i32, i32),
        visited_tiles: &HashSet<(usize, usize)>,
        visited_locations: &mut HashSet<(usize, usize)>,
        direction: Direction,
    ) {
        if r >= 0 && r < 140 && c >= 0 && c < 140 {
            
            let ru = r as usize;
            let cu = c as usize;

            if !visited_locations.contains(&(ru, cu)) {
                if !visited_tiles.contains(&(ru, cu)) {
                    self.grid[ru][cu] = Pipe::S;
                    visited_locations.insert((ru, cu));
                    // self.mark_sea((r - 1, (c - 1)), visited_tiles, visited_locations);
                    // self.mark_sea((r - 1, (c + 1)), visited_tiles, visited_locations);
                    // self.mark_sea((r + 1, (c - 1)), visited_tiles, visited_locations);
                    self.mark_sea((r, (c - 1)), visited_tiles, visited_locations, Direction::West);
                    self.mark_sea((r - 1, c), visited_tiles, visited_locations, Direction::North);
                    // self.mark_sea((r + 1, (c + 1)), visited_tiles, visited_locations);
                    self.mark_sea((r + 1, c), visited_tiles, visited_locations, Direction::South);
                    self.mark_sea((r, (c + 1)), visited_tiles, visited_locations, Direction::East);
                }else {
                    match direction {
                        Direction::East => if [Pipe::H, Pipe::J, Pipe::D7].contains(&self.grid[ru][cu]) {
                            self.grid[ru][cu] = Pipe::S;
                            visited_locations.insert((ru, cu));
                        },
                        Direction::West => if [Pipe::V, Pipe::H, Pipe::F, Pipe::L].contains(&self.grid[ru][cu]) {
                            self.grid[ru][cu] = Pipe::S;
                            visited_locations.insert((ru, cu));
                        },
                        Direction::North => if [Pipe::V, Pipe::H, Pipe::D7, Pipe::F].contains(&self.grid[ru][cu]) {
                            self.grid[ru][cu] = Pipe::S;
                            visited_locations.insert((ru, cu));
                        },
                        Direction::South => if [Pipe::J, Pipe::V, Pipe::D7].contains(&self.grid[ru][cu]) {
                            self.grid[ru][cu] = Pipe::S;
                            visited_locations.insert((ru, cu));
                        },
                    }
                    
                }
            } 
        }
    }

    fn part1(&mut self) -> String {
        let from = Direction::North;
        let target_pos = self.find_target_direction_and_coordinate(self.start_pos, from);

        let mut visited_tiles: HashSet<(usize, usize)> = HashSet::new();
        let visited_tiles = self.traverse_path(target_pos, &mut visited_tiles);

        let mut visited_locations: HashSet<(usize, usize)> = HashSet::new();

        // self.mark_sea((0, 0), &visited_tiles, &mut visited_locations, Direction::East);
        
        let mut s = String::new();

     

        for r in 0..self.grid.len() {
            
            for c in 0..self.grid[0].len() {
                if (r,c) == self.start_pos {
                    s.push('*')
                }
                else if !visited_tiles.contains(&(r, c)) {
                    if self.grid[r][c] != Pipe::G {
                        s.push(' ')
                    } else {
                        s.push('.')
                    }
                } else {
                    let ch = match self.grid[r][c] {
                        Pipe::V => {
                            '|'
                        },
                        Pipe::H => '-',
                        Pipe::L => 'L',
                        Pipe::J => 'J',
                        Pipe::D7 => '7',
                        Pipe::F => 'F',
                        Pipe::G => {
                          
                            '.'
                        },
                        Pipe::S => '*',
                    };
                    s.push(ch);
                }
            }
        }

        let new_count = s.chars().filter(|c| *c == '.').count();
        let farthest_distance = (visited_tiles.len() + 1) / 2;

        println!("{new_count:?}");
        println!("{s:?}");
        println!("{farthest_distance:?}");


        farthest_distance.to_string()
    }
}

impl FromStr for Input {
    type Err = ();

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Ok(Input::new(s))
    }
}

fn main() {
    let contents = fs::read_to_string("../../input/day10").unwrap();
    let mut input = contents.parse::<Input>().unwrap();
    let _x = input.part1();
    // println!("{}", input.part1());
}
